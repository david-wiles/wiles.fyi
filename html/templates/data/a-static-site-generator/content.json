{
  "title": "A Static Site Generator",
  "html": "<p>\n  One of the first projects I completed this year was out of necessity for this website: a static site generator.\n  Although there are many (probably thousands) of perfectly good static site generation frameworks out there, I didn’t\n  want to spend the time learning new syntax and CLI commands. My final implementation is very simple, a bare-bones\n  template engine.\n</p>\n\n<h2>Origins\n</h2>\n\n<p>The website I created the site generator for (this website) went through several iterations of architectural designs,\n  which is described in more detail in this post. Once I had finally abandoned a Wordpress-style generated site for a\n  statically generated site, I needed to chose a project to create the static HTML files, and my final decision was to\n  simply make my own. My site is a simple blog with very simple requirements, so the final product has functionality to\n  meet them.\n</p>\n\n<h2>Syntax\n</h2>\n\n<p>There are plenty of options for commonly used syntax in template engines, but most will either mimic HTML syntax by\n  adding tags with special meaning or use special characters to denote meaning in the syntax. I modeled mine after the\n  template language used by Go (which is also very similar to the Jinja2 template syntax).\n</p>\n\n<p>There are only two statements in the syntax:\n</p>\n<ul>\n  <li>\n    <strong>{{ template “&lt;template to insert&gt;” [“&lt;data file to use&gt;”] }}</strong> - used to insert the specified template into the current location in the file. The\n        template is located relative to the current template directory, which is the templates/ directory under the root\n        directory of the project\n  </li>\n  <li>\n    <strong>{{ &lt;data key&gt; }}</strong> - inserts the value with the specified key in the current context. To simplify things, the context\n      does not extend past the current template. This content is specified using the second argument to the template\n      function.\n  </li>\n</ul>\n\n<h2>Development Process</h2>\n\n<p>If you look through the commit history for this project you will find that this was originally built with TypeScript.\n  Although TypeScript is a wonderful language, it added too much complexity to an otherwise simple project, and the\n  newest version is a basic JavaScript project.\n</p>\n\n<p>In the original TypeScript version of the project, I put too much emphasis on extendability. The project was setup\n  similar to Webpack, where each file is processed through a pipeline with the output of one step as the input to\n  another. Although this could be useful if other transformations to the HTML were required (such as minification), this\n  turned out to be out of the scope of the project and somewhat unnecessary due to the existence of established build\n  tools.\n</p>\n<p>Additionally, one of my original plans was to include an optional Markdown to HTML transformation step in the\n  pipeline. There are many advantages to this, but one of the bigger advantages is to enable people without knowledge of\n  HTML to create web pages. It turned out to be extra complexity that my project didn’t need, so I ended up scrapping\n  the original project in lieu of a plain JS project without a complicated pipeline built into the project.\n</p>\n\n<h2>Latest</h2>\n\n<p>The latest version of this project can be found on GitHub at https://github.com/david-wiles/site-generator. It is a\n  plain nodeJS project which can be used from the command line or programmatically. There are only three command options\n  to be used by the CLI: —root, —out, and —watch. The flags indicate the root directory, output directory, and whether\n  to watch the directory for file changes, respectively.\n</p>\n<p>Three functions are exposed in the project’s index.js: build, buildDir, and watch.</p>\n\n<pre><code class=\"language-js\">\n  build(template: string, tDir: string): string\n</code></pre>\n\n<p>build() will build the HTML file found at the specified path, using the tDir as the base directory to search for\n  templates.\n</p>\n\n<pre><code class=\"language-js\">\n  buildDir(dir: string, out: string): void\n</code></pre>\n\n<p>buildDir() looks through the directory and builds all pages not located in a directory called “/templates” directly\n  under the root directory. Files are written to the specified output directory.\n</p>\n\n<pre><code class=\"language-js\">\n  watch(dir: string, out: string): void\n</code></pre>\n\n<p>\n  watch() is similar to buildDir(), except that files are only written when changes are detected.\n</p>\n\n<p>\n  I use this project to generate the HTML files for this site, and then use more build steps to inline the JS and CSS.\n  Since I've started using the project for an actual site, I see why other static site generators have a CLI built-in to\n  generate project files. However, I'm still enjoying using my little site generator to make this website.\n</p>\n"
}
